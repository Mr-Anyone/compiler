function add_two gives int[
    int a,
    int b,
]{
    ret a +b;
}

function is_equal gives int[
    int a,
    int b,
]{
    ret (a eq b) + (a ne b) + (a le b) + (a lt b) + (a ge b) + (a gt b);
}

function test_three gives int [
    int a,
    int b,
]{
    ret a ne b;
}

function fib gives int[
    int a,
]{
    if a le 1 then 
        ret a;
    end

    ret fib(a-1 ,) + fib(a-2,);
}

struct complex{
    int a, 
    int b,
}

struct inner{
    int a,
    int b,
}

struct outer{
    int a,
    int b,
    struct inner c,
}

function test_struct gives int[
    int a,
    int b,
    struct outer c,
]{
    ret a + b + c.c.b;
}

struct some_placeholder{
    int a,
}

function test_no_expression_declaration_statement
gives int[
    int a,
    int b,
] {
    int c;
    int d;
    c = 20;
    d = 40;
    struct some_placeholder e;
    ret a + b + c + d;
}

function test_array_parameter 
gives int[
    array (10) struct some_placeholder a, 
    array (10) array (20) int b,
]{
    ret 10;
}

function some_test_t 
gives int [
    ptr int a, 
]{
    ret a;
}
struct inner_two{
    array (100) int get,
}

struct outer_two{
    struct inner_two testing,
}

function test_array_access
gives int [
    int c,
]{
    array (10) array (130) struct inner_two  b;
    ret  b[8][123].get[10] + c;
}

struct most_basic_struct{
    int a,
}

function test_struct_two
gives int[
    int a,
]{
    struct most_basic_struct test; 
    ret a + test.a;
}

function test_float_add 
gives float[
    float a, 
    float b, 
]{
    ret a + b;
}

# testing one
function test_comments #testing two
gives float [#real test
    float a, 
    float b,
] {
    ret a + b;
}    #asfasd

 function test_twod_array  # this is some sort of test
 gives int[
     ptr ptr int a, 
 ]{
     ret a[10][10];
 }

function binary_search 
gives int[
    ptr int start, 
    int target,
    int size,
]{
    int low = 0; 
    int high = size;

    # inside of the while true loop we need to do the following
    while low le high then 
        int mid = low + (high - low) / 2;

        if start[mid] eq target then 
            ret mid;
        end

        if start[mid] gt target then 
            high = mid - 1; 
        end 

        if start[mid] lt target then 
            low = mid + 1;
        end
    end

    ret 100;
}
